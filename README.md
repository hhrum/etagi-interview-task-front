# etagi-interview-task-front

Front-end часть из "Тестового задания" для трудоустройства в "Этажи"

Репозиторий был создан командой `npx create-react-app etagi-interview-task-front --template=typescript`.
Пакеты, автоматически подтянутые CLI решил не описывать

В очередной раз извиняюсь за задержку, был загружен аутсорс заказами, только в воскресенье нормально освободился, там и смог начать код писать с:

В сумме на выполнение задачи ушло около 3 дней.

## архитектура

В качестве эксперимента выбрал [FSD](https://feature-sliced.design/ru/docs/get-started/overview), как основу. Результатом в целом доволен.

> В некоторых местах code-style может отличаться, т.к. из личного интереса пробывал различные варианты по структурам папок внутри модулей

> Местами могут быть кринж моменты, т.к. первое время плохо понимал, как лучше работать с FSD

### немного-об-FSD

Архитектура позволяет задать строгое направления зависимость. Это достигается путём разбиения структуры папок на 7 слоёв (app, processors, pages, widgets, features, entities, shared), в котором верхний слой (например `app`) может использовать нижний слой (например `entities`), но нижний слой не может использовать верхний. Каждый из слоёв делится на Slices(модули), при этом, модули одного слоя не могут использовать друг друга. Также, слой `shared` не может содержать какую-либо бизнес логику

### мои-замечания-по-архитектуре

Как и ожидалось, не очень подходит для быстрых проектов, таких как тестовое задание. Слишком медленный старт был, но под конец выполнения было приятно работать, т.к. была полная осознанность в том, что делаю

На мой взгляд, она не очень подходит для Redux в связке с Typescript. Т.к. я получал из экземпляра стора `RootState` для типизации моих селекторов, направление зависимостей всегда менялось, куда бы я не попробовал засунуть сам `store`. Проблема решалась бы, если бы я поместил его в `shared`, но этот слой не может содержать какую-либо бизнес-логику. Поэтому я принял решение добавить ещё один слой store, который могли использовать все слои, кроме shared. В целом, решением также доволен

### о-принятом-нейминге-файлов-и-папок

Устал от PascalCase в нейминге папок и файлов, поэтому везде использова кебабкейс. Так и импорты красиво выглядят, и читаемость получше, на мой взгляд

### импорты

Настроил prettier для сортирвоки импортов в соответствии методологии. + настроил `tsconfig.json`, чтобы в качестве `baseUrl` использовался `src`. Это такой ленивый вариант для алиасов.

## стек-используемых-технологий

* [TS](https://www.typescriptlang.org/) - использовал для типизации, без неё уже не то :с
* [React](https://www.typescriptlang.org/)
* [React-redux](https://react-redux.js.org/) - использовал в качестве глобального стора
* [@reduxjs/toolkit](https://react-redux.js.org/) - вспомогательная библиотека для `redux`, которая упрощает работу с ним
* [Redux-saga](https://redux-saga.js.org/) - использовал для асинхронных взаимодействий со стором. Предпочитаю её больше, чем `redux-thunk`. 
* [sass](https://www.npmjs.com/package/sass) - препроцессор для `CSS`, на проекте использовался `SCSS`. Аналог `node-sass`, но лучше) (не зависим от используемой версии node.js)
* [axios](https://www.npmjs.com/package/sass) - использовал для запросов к API, упрощает работу с запросами (осозновал, что достаточно было бы и fetch использовать, но с ней как-то по привычнее
* [classnames](https://www.npmjs.com/package/classnames) - небольшая библиотека, которая помогает комбинировать классы для компонентов
* [Eslint](https://eslint.org/)
* [Prettier](https://prettier.io/)
* [Craco](https://craco.js.org/) - если правильно всё понимаю, то craco это как обёртка над webpack, которая позволяет переписать его настройки. Дело в том, что при использовании CLI, мы не имеем доступа к конфигурации webpack. Использовал для подключения файлов с SCSS переменными и миксинами во все рабочие файлы. Требуеся для того, чтобы не прописывать import в стилях, когда тебе нужно использовать какую-то глобальную переменную/миксин

